// Code generated by tinyjson for marshaling/unmarshaling. DO NOT EDIT.

package types

import (
	tinyjson "github.com/CosmWasm/tinyjson"
	jlexer "github.com/CosmWasm/tinyjson/jlexer"
	jwriter "github.com/CosmWasm/tinyjson/jwriter"
	types "k8s.io/apimachinery/pkg/types"
)

// suppress unused package warning
var (
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ tinyjson.Marshaler
)

func tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes(in *jlexer.Lexer, out *UserInfo) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "username":
			out.Username = string(in.String())
		case "uid":
			out.UID = string(in.String())
		case "groups":
			if in.IsNull() {
				in.Skip()
				out.Groups = nil
			} else {
				in.Delim('[')
				if out.Groups == nil {
					if !in.IsDelim(']') {
						out.Groups = make([]string, 0, 4)
					} else {
						out.Groups = []string{}
					}
				} else {
					out.Groups = (out.Groups)[:0]
				}
				for !in.IsDelim(']') {
					var v1 string
					v1 = string(in.String())
					out.Groups = append(out.Groups, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "extra":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				if !in.IsDelim('}') {
					out.Extra = make(map[string]ExtraValue)
				} else {
					out.Extra = nil
				}
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v2 ExtraValue
					if in.IsNull() {
						in.Skip()
						v2 = nil
					} else {
						in.Delim('[')
						if v2 == nil {
							if !in.IsDelim(']') {
								v2 = make(ExtraValue, 0, 4)
							} else {
								v2 = ExtraValue{}
							}
						} else {
							v2 = (v2)[:0]
						}
						for !in.IsDelim(']') {
							var v3 string
							v3 = string(in.String())
							v2 = append(v2, v3)
							in.WantComma()
						}
						in.Delim(']')
					}
					(out.Extra)[key] = v2
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes(out *jwriter.Writer, in UserInfo) {
	out.RawByte('{')
	first := true
	_ = first
	if in.Username != "" {
		const prefix string = ",\"username\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.Username))
	}
	if in.UID != "" {
		const prefix string = ",\"uid\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.UID))
	}
	if len(in.Groups) != 0 {
		const prefix string = ",\"groups\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('[')
			for v4, v5 := range in.Groups {
				if v4 > 0 {
					out.RawByte(',')
				}
				out.String(string(v5))
			}
			out.RawByte(']')
		}
	}
	if len(in.Extra) != 0 {
		const prefix string = ",\"extra\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		{
			out.RawByte('{')
			v6First := true
			for v6Name, v6Value := range in.Extra {
				if v6First {
					v6First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v6Name))
				out.RawByte(':')
				if v6Value == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
					out.RawString("null")
				} else {
					out.RawByte('[')
					for v7, v8 := range v6Value {
						if v7 > 0 {
							out.RawByte(',')
						}
						out.String(string(v8))
					}
					out.RawByte(']')
				}
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v UserInfo) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v UserInfo) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *UserInfo) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *UserInfo) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes(l, v)
}
func tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes1(in *jlexer.Lexer, out *RawExtension) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes1(out *jwriter.Writer, in RawExtension) {
	out.RawByte('{')
	first := true
	_ = first
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v RawExtension) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes1(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v RawExtension) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes1(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RawExtension) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes1(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *RawExtension) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes1(l, v)
}
func tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes2(in *jlexer.Lexer, out *HookRequest) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "subResource":
			out.SubResource = string(in.String())
		case "requestSubResource":
			out.RequestSubResource = string(in.String())
		case "name":
			out.Name = string(in.String())
		case "namespace":
			out.Namespace = string(in.String())
		case "operation":
			out.Operation = Operation(in.String())
		case "dryRun":
			if in.IsNull() {
				in.Skip()
				out.DryRun = nil
			} else {
				if out.DryRun == nil {
					out.DryRun = new(bool)
				}
				*out.DryRun = bool(in.Bool())
			}
		case "uid":
			out.UID = types.UID(in.String())
		case "kind":
			(out.Kind).UnmarshalTinyJSON(in)
		case "resource":
			(out.Resource).UnmarshalTinyJSON(in)
		case "requestKind":
			if in.IsNull() {
				in.Skip()
				out.RequestKind = nil
			} else {
				if out.RequestKind == nil {
					out.RequestKind = new(GroupVersionKind)
				}
				(*out.RequestKind).UnmarshalTinyJSON(in)
			}
		case "requestResource":
			if in.IsNull() {
				in.Skip()
				out.RequestResource = nil
			} else {
				if out.RequestResource == nil {
					out.RequestResource = new(GroupVersionResource)
				}
				(*out.RequestResource).UnmarshalTinyJSON(in)
			}
		case "userInfo":
			(out.UserInfo).UnmarshalTinyJSON(in)
		case "object":
			(out.Object).UnmarshalTinyJSON(in)
		case "oldObject":
			(out.OldObject).UnmarshalTinyJSON(in)
		case "options":
			(out.Options).UnmarshalTinyJSON(in)
		case "Result":
			out.Result = bool(in.Bool())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes2(out *jwriter.Writer, in HookRequest) {
	out.RawByte('{')
	first := true
	_ = first
	if in.SubResource != "" {
		const prefix string = ",\"subResource\":"
		first = false
		out.RawString(prefix[1:])
		out.String(string(in.SubResource))
	}
	if in.RequestSubResource != "" {
		const prefix string = ",\"requestSubResource\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.RequestSubResource))
	}
	if in.Name != "" {
		const prefix string = ",\"name\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Name))
	}
	if in.Namespace != "" {
		const prefix string = ",\"namespace\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Namespace))
	}
	{
		const prefix string = ",\"operation\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}
		out.String(string(in.Operation))
	}
	if in.DryRun != nil {
		const prefix string = ",\"dryRun\":"
		out.RawString(prefix)
		out.Bool(bool(*in.DryRun))
	}
	{
		const prefix string = ",\"uid\":"
		out.RawString(prefix)
		out.String(string(in.UID))
	}
	{
		const prefix string = ",\"kind\":"
		out.RawString(prefix)
		(in.Kind).MarshalTinyJSON(out)
	}
	{
		const prefix string = ",\"resource\":"
		out.RawString(prefix)
		(in.Resource).MarshalTinyJSON(out)
	}
	if in.RequestKind != nil {
		const prefix string = ",\"requestKind\":"
		out.RawString(prefix)
		(*in.RequestKind).MarshalTinyJSON(out)
	}
	if in.RequestResource != nil {
		const prefix string = ",\"requestResource\":"
		out.RawString(prefix)
		(*in.RequestResource).MarshalTinyJSON(out)
	}
	{
		const prefix string = ",\"userInfo\":"
		out.RawString(prefix)
		(in.UserInfo).MarshalTinyJSON(out)
	}
	if true {
		const prefix string = ",\"object\":"
		out.RawString(prefix)
		(in.Object).MarshalTinyJSON(out)
	}
	if true {
		const prefix string = ",\"oldObject\":"
		out.RawString(prefix)
		(in.OldObject).MarshalTinyJSON(out)
	}
	if true {
		const prefix string = ",\"options\":"
		out.RawString(prefix)
		(in.Options).MarshalTinyJSON(out)
	}
	{
		const prefix string = ",\"Result\":"
		out.RawString(prefix)
		out.Bool(bool(in.Result))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v HookRequest) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v HookRequest) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *HookRequest) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes2(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *HookRequest) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes2(l, v)
}
func tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes3(in *jlexer.Lexer, out *GroupVersionResource) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "group":
			out.Group = string(in.String())
		case "version":
			out.Version = string(in.String())
		case "resource":
			out.Resource = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes3(out *jwriter.Writer, in GroupVersionResource) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"group\":"
		out.RawString(prefix[1:])
		out.String(string(in.Group))
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.String(string(in.Version))
	}
	{
		const prefix string = ",\"resource\":"
		out.RawString(prefix)
		out.String(string(in.Resource))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v GroupVersionResource) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes3(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v GroupVersionResource) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes3(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GroupVersionResource) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes3(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *GroupVersionResource) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes3(l, v)
}
func tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes4(in *jlexer.Lexer, out *GroupVersionKind) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "group":
			out.Group = string(in.String())
		case "version":
			out.Version = string(in.String())
		case "kind":
			out.Kind = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes4(out *jwriter.Writer, in GroupVersionKind) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"group\":"
		out.RawString(prefix[1:])
		out.String(string(in.Group))
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.String(string(in.Version))
	}
	{
		const prefix string = ",\"kind\":"
		out.RawString(prefix)
		out.String(string(in.Kind))
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v GroupVersionKind) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes4(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalTinyJSON supports tinyjson.Marshaler interface
func (v GroupVersionKind) MarshalTinyJSON(w *jwriter.Writer) {
	tinyjsonA17a9c65EncodeWasmhookPkgWasmhelperTypes4(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *GroupVersionKind) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes4(&r, v)
	return r.Error()
}

// UnmarshalTinyJSON supports tinyjson.Unmarshaler interface
func (v *GroupVersionKind) UnmarshalTinyJSON(l *jlexer.Lexer) {
	tinyjsonA17a9c65DecodeWasmhookPkgWasmhelperTypes4(l, v)
}
